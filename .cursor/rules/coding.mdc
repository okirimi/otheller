---
description:
globs: *.py,*.js
alwaysApply: false
---
# Coding standards

コードの追加、修正、リファクタリングなど、あらゆる開発作業において**必ず遵守すべきコーディング規約**を定めています。

## SOLID原則

**SOLID原則**は、モジュール設計や責務の分離、拡張性・保守性を高めるための**最も基本的かつ厳格な設計方針**であり、すべての開発者が一貫して守らなければなりません。

### 単一責任の原則（Single Responsibility Principle）

**クラスは単一の責任のみを持つべきであり、クラスが変更される理由は一つだけであるべきである。**
- 責任（Responsibility）とは、**モジュールやクラスの変更理由（Reason to change）**を指す。
- クラスは1つのことを行うべきという意味ではない。
- 同じロジックは1つにまとめて共通化しようという話ではない。むしろ、変更理由を持つ主体（Responsible party）が異なるならモジュールを分離し、それぞれに対応したモジュールを作成すべきである。

---

### オープン/クローズドの原則（Open/Closed Principle）

**モジュールは、拡張に対しては開いていて（Open for extension）、変更に対しては閉じていなければならない（Closed for modification）。**
- 拡張に対して開かれているとは、新しいコードを追加することで機能を追加できることを表す。
- 変更に対して閉じているとは、既存のコードを変更しないで機能追加ができることを表す。

---

### リスコフの置換原則（Liskov Substitution Principle）

**サブタイプ（Subtype）は、そのスーパータイプ（Supertype）と置換可能でなければならない。**
- サブタイプのインスタンスは、スーパータイプのインスタンスと同じように振る舞うべきである。
- サブタイプとは、スーパータイプを継承したクラスを指す。
- 継承時は、スーパータイプの代わりにサブタイプを利用しても、不都合のないようにしなければならない。
- リスコフの置換原則を満たさないならば、継承（Inheritance）を利用すべきではない。

---

### インターフェース分離の原則（Interface Segregation Principle）

**インターフェースのクライアントに、クライアントが利用しないプロパティやメソッドへの依存（Dependency）を強制してはならない。**
- クライアント（Client）からは、必要なメソッドのみが見えるべきであり、使わないメソッドが見えてはならない。
- クライアントで一部のメソッドが未実装になる場合は、インターフェースの分離（Segregation）を検討すべきである。

---

### 依存性逆転の原則（Dependency Inversion Principle）

**依存性逆転の原則とは、次の2つの原則を含む。**

1. **上位レベルのモジュール（High-level module）は下位レベルのモジュール（Low-level module）に依存してはならない。両者は抽象（Abstraction）に依存すべきである。**
2. **抽象（Abstraction）は詳細（Detail）に依存してはならない。詳細が抽象に依存すべきである。**

- 「依存する（Depend）」とは、あるモジュールが別のモジュールの機能を利用することを指す。このとき、利用する側が上位モジュールで、利用される側が下位モジュールである。
- 「抽象（Abstraction）」とは、インターフェースや抽象クラスのように、具体的な実装に依存しない仕様そのものを指す。例えば「保存する」という処理は抽象であり、「ファイルに保存」「データベースに保存」などは詳細（Detail）である。
- モジュールAがモジュールBを直接利用するのではなく、間に抽象（Interface）を挟み、AとBの両者がその抽象に依存する形にすべきである。

---

## GRASP（General Responsibility Assignment Software Patterns）

**GRASP**は、責務（Responsibility）の適切な割り当てを通じて、柔軟で保守性の高いオブジェクト指向設計を実現するための指針です。SOLID原則とあわせて設計方針の基盤となる考え方であり、全ての開発者ができる限り遵守すべき指針です。

---

### 情報エキスパート（Information Expert）

**必要な情報を最も多く持っているクラスに、その情報を使う責務を与えるべきである。**

- 責務を果たすために必要なデータを保持しているクラスが最適な実装者となる。
- 情報の局所化を促進し、結合度を下げる効果がある。

---

### 生成者（Creator）

**インスタンスAを作成するべきなのは、Aとの関係性が深いクラスBである。**

- 以下の条件のいずれかを満たす場合、クラスBはクラスAの生成者とされる。
  - BがAを集約している（has-a関係）。
  - BがAを保持している。
  - BがAの初期化情報を持っている。
  - BがAのライフサイクルを管理している。
  - BがAを頻繁に使用する。

---

### コントローラ（Controller）

**システムイベントの処理は、UIではなくコントローラに任せるべきである。**

- コントローラは、UIやインターフェースとインタラクトしてはならない。

---

### 疎結合（Low Coupling）

**クラス同士の依存はできるだけ弱く保つべきである。**

---

### 高凝集（High Cohesion）

**1つのクラスに割り当てる責務は、互いに関連の深いものに限定すべきである。**

---

### 多態性（Polymorphism）

**変化する振る舞いは、ポリモーフィズムを用いて抽象クラスやインターフェースで表現し、具体的な実装はサブクラスで提供すべきである。**

- 拡張性と保守性を高め、リスコフの置換原則とも親和性が高い。

---

### 純粋人工物（Pure Fabrication）

**凝集性と結合度のバランスをとるために、抽象クラスを導入すべきである。**

システムを設計するとき、高凝集性と疎結合性は矛盾する。高凝集性はクラスを細分化して、責務をそれぞれに集中させるが、それぞれのクラスは協力し合わないと動作しないため、結合性を高くしてしまう。そのような場合は抽象クラスを作成し、凝集性と結合性をバランスを調整すべきである。

---

### 間接化（Indirection）

**2つのクラスの強い依存関係を避けるために、仲介役となるクラスを挟むべきである。**

これにより疎結合を促進することができる。

---

### 変動からの保護（Protected Variations）

**変化しやすい部分は、安定したインターフェースでカプセル化し、変化に強い構造を作るべきである。**
